import textwrap
import os
import json
import hashlib
import base64

def indent(str, n = 1, predicate = None):
  return textwrap.indent(str, "  " * n, predicate)

dedent = textwrap.dedent

def hash(str):
  return base64.urlsafe_b64encode(hashlib.shake_128(str.encode(
    "utf-8")).digest(12)).decode().replace("-", "+")

def header_sep(file):
  sep = "\n"
  rel_file_path = os.path.relpath(file,
    os.path.join(os.path.dirname(file), "..", "src"))
  return f'// File generated by `{rel_file_path}`\n' + sep, sep

def load_and_expand_jsons():
  sensors_json_filename = os.path.join(os.path.dirname(__file__),
    "sensors.json")
  control_structs_json_filename = os.path.join(os.path.dirname(__file__),
    "control-structs.json")

  with open(sensors_json_filename, "r") as f:
    sensors = json.load(f)
  with open(control_structs_json_filename, "r") as f:
    control_structs = json.load(f)

  for host_identifier, host_structs in control_structs.items():
    struct_params = control_structs[host_identifier]["struct_params"]
    struct_state  = control_structs[host_identifier]["struct_state" ]

    for sensor_input in control_structs[host_identifier]["sensor_inputs"]:
      sensor_name, variable_name = sensor_input["sensor"], sensor_input["name"]
      sensor_field = sensors[sensor_name][variable_name]
      physical_name = sensor_input["sensor_physical_instance_name"]
      input_name = physical_name + "_" + variable_name
      struct_state.append({
        "name": input_name,
        "type": sensor_field["type"],
        "width": sensor_field["width"],
        "decimals": sensor_field["decimals"],
        "default": sensor_input["default"]})
      for bound in ["min", "max"]:
        if bound in sensor_input:
          struct_params.append({
            "name": input_name + "_" + bound,
            "type": sensor_field["type"],
            "width": sensor_field["width"],
            "decimals": sensor_field["decimals"],
            "default": sensor_input[bound]})

    for thr_spec in control_structs[host_identifier]["thresholds"]:
      variable_name, target_name = thr_spec["variable"], thr_spec["target"]
      prefix = target_name + "_by_" + variable_name + "_"
      variable_spec = struct_state[next((i for i, field
        in enumerate(struct_state) if field["name"] == variable_name))]
      for spec in ["threshold", "threshold_gap"]:
        struct_params.append({
          "name": prefix + spec,
          "type": variable_spec["type"],
          "width": variable_spec["width"],
          "decimals": variable_spec["decimals"],
          "default": thr_spec[spec]})
      for spec in ["active_region_is_above", "active_state_is_on"]:
        struct_params.append({
          "name": prefix + spec,
          "type": "bool",
          "default": "true" if thr_spec[spec] else "false"})
      has_any_hold_time_specs = False
      for active in [False, True]:
        for subspec in ["min", "max", "override"]:
          spec = "hold_time_" + ("" if active else "in") + "active_" + subspec
          if spec in thr_spec:
            has_any_hold_time_specs = True
            struct_params.append({
              "name": prefix + spec,
              "type": "float",
              "width": 5,
              "decimals": 1,
              "default": thr_spec[spec]})
      if has_any_hold_time_specs:
        struct_state.append({
          "name": prefix + "hold_time_counter",
          "type": "float",
          "width": 5,
          "decimals": 1,
          "default": "0.f"})

  for host_identifier, structs in control_structs.items():
    for type_identifier in ["state", "params"]:
      sensor = {field["name"]: field
        for field in structs[f'struct_{type_identifier}']}
      for field_name, field_params in sensor.items():
        if not "aggregate" in field_params:
          field_params["aggregate"] = "first"
      sensors[f'control_{type_identifier}_{host_identifier}'] = sensor

  return sensors, control_structs

def generated_cpp_file_path(name):
  return os.path.join(os.path.dirname(__file__), "..", "src",
    f"{name}.generated.cpp")

def write_generated_cpp_file(name, str):
  with open(generated_cpp_file_path(name), "w") as f:
    f.write(str)

  # print(string, end = "")
