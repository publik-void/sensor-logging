// File generated by `../script/generate-sensors-include.py`

namespace sensors {

  std::string bool_as_csv_string(bool const x) {
    return std::string{x ? "1" : "0"};
  }

  auto constexpr aggregation_step_mean{
    [](auto const &x0, auto const &x1){ return x0 + x1; }};
  auto constexpr aggregation_step_min{
    [](auto const &x0, auto const &x1){ return std::min(x0, x1); }};
  auto constexpr aggregation_step_max{
    [](auto const &x0, auto const &x1){ return std::max(x0, x1); }};
  auto constexpr aggregation_step_first{
    [](auto const &x0, auto const &){ return x0; }};

  struct sensor {
    std::optional<cc::timestamp_duration_t> timestamp{};
  };

  struct sensorhub : public sensor {
    std::optional<float> ntc_temperature{};
    std::optional<bool> ntc_overrange{};
    std::optional<bool> ntc_error{};
    std::optional<float> dht11_temperature{};
    std::optional<float> dht11_humidity{};
    std::optional<bool> dht11_error{};
    std::optional<float> bmp280_temperature{};
    std::optional<float> bmp280_pressure{};
    std::optional<bool> bmp280_error{};
    std::optional<float> brightness{};
    std::optional<bool> brightness_overrange{};
    std::optional<bool> brightness_error{};
    std::optional<float> motion{};
  };

  struct dht22 : public sensor {
    std::optional<float> temperature{};
    std::optional<float> humidity{};
  };

  struct mhz19 : public sensor {
    std::optional<float> co2_concentration{};
    std::optional<float> temperature{};
    std::optional<int> status{};
    std::optional<int> u0{};
    std::optional<int> u1{};
  };

  struct lpd433_receiver : public sensor {
    std::optional<uint64_t> code{};
    std::optional<int> n_bits{};
    std::optional<int> intercode_gap{};
    std::optional<int> pulse_length_short{};
    std::optional<int> pulse_length_long{};
  };

  struct sensor_state {
    unsigned timestamp_count{0u};
  };

  struct sensorhub_state : public sensor_state {
    unsigned ntc_temperature_count{0u};
    unsigned dht11_temperature_count{0u};
    unsigned dht11_humidity_count{0u};
    unsigned bmp280_temperature_count{0u};
    unsigned bmp280_pressure_count{0u};
    unsigned brightness_count{0u};
    unsigned motion_count{0u};
  };

  struct dht22_state : public sensor_state {
    unsigned temperature_count{0u};
    unsigned humidity_count{0u};
  };

  struct mhz19_state : public sensor_state {
    unsigned co2_concentration_count{0u};
    unsigned temperature_count{0u};
  };

  struct lpd433_receiver_state : public sensor_state {
  };

  auto init_state(sensor const &) {
    return sensor_state{};
  }

  auto init_state(sensorhub const &) {
    return sensorhub_state{};
  }

  auto init_state(dht22 const &) {
    return dht22_state{};
  }

  auto init_state(mhz19 const &) {
    return mhz19_state{};
  }

  auto init_state(lpd433_receiver const &) {
    return lpd433_receiver_state{};
  }

  auto setup_sensor_io(auto const &pi, auto const &);

  auto setup_io(sensor const &, auto const &pi, auto const &args) {
    return setup_sensor_io(pi, args);
  }

  auto setup_sensorhub_io(auto const &pi, auto const &);

  auto setup_io(sensorhub const &, auto const &pi, auto const &args) {
    return setup_sensorhub_io(pi, args);
  }

  auto setup_dht22_io(auto const &pi, auto const &);

  auto setup_io(dht22 const &, auto const &pi, auto const &args) {
    return setup_dht22_io(pi, args);
  }

  auto setup_mhz19_io(auto const &pi, auto const &);

  auto setup_io(mhz19 const &, auto const &pi, auto const &args) {
    return setup_mhz19_io(pi, args);
  }

  auto setup_lpd433_receiver_io(auto const &pi, auto const &);

  auto setup_io(lpd433_receiver const &, auto const &pi, auto const &args) {
    return setup_lpd433_receiver_io(pi, args);
  }

  sensor sample_sensor(auto const &, auto const &);

  sensor sample(sensor const &, auto const &clock, auto const &sensor_io) {
    return sample_sensor(clock, sensor_io);
  }

  sensorhub sample_sensorhub(auto const &, auto const &);

  sensorhub sample(sensorhub const &, auto const &clock, auto const &sensor_io) {
    return sample_sensorhub(clock, sensor_io);
  }

  dht22 sample_dht22(auto const &, auto const &);

  dht22 sample(dht22 const &, auto const &clock, auto const &sensor_io) {
    return sample_dht22(clock, sensor_io);
  }

  mhz19 sample_mhz19(auto const &, auto const &);

  mhz19 sample(mhz19 const &, auto const &clock, auto const &sensor_io) {
    return sample_mhz19(clock, sensor_io);
  }

  lpd433_receiver sample_lpd433_receiver(auto const &, auto const &);

  lpd433_receiver sample(lpd433_receiver const &, auto const &clock, auto const &sensor_io) {
    return sample_lpd433_receiver(clock, sensor_io);
  }

  auto aggregation_step(
      sensor const aggregate,
      sensor_state const state,
      sensor const sample) {
    auto const timestamp{util::optional_apply(aggregation_step_mean,
      aggregate.timestamp, sample.timestamp)};
    auto const timestamp_count{state.timestamp_count + 
      (sample.timestamp.has_value() ? 1u : 0u)};

    return std::pair<sensor, sensor_state>{{
        timestamp,
      }, {
        timestamp_count,
      }
    };
  }

  auto aggregation_step(
      sensorhub const aggregate,
      sensorhub_state const state,
      sensorhub const sample) {
    auto const [base_aggregate, base_state]{
      aggregation_step(static_cast<sensor>(aggregate),
                       static_cast<sensor_state>(state),
                       static_cast<sensor>(sample))};
    auto const ntc_temperature{util::optional_apply(aggregation_step_mean,
      aggregate.ntc_temperature, sample.ntc_temperature)};
    auto const ntc_temperature_count{state.ntc_temperature_count + 
      (sample.ntc_temperature.has_value() ? 1u : 0u)};
    auto const ntc_overrange{util::optional_apply(aggregation_step_max,
      aggregate.ntc_overrange, sample.ntc_overrange)};
    auto const ntc_error{util::optional_apply(aggregation_step_min,
      aggregate.ntc_error, sample.ntc_error)};
    auto const dht11_temperature{util::optional_apply(aggregation_step_mean,
      aggregate.dht11_temperature, sample.dht11_temperature)};
    auto const dht11_temperature_count{state.dht11_temperature_count + 
      (sample.dht11_temperature.has_value() ? 1u : 0u)};
    auto const dht11_humidity{util::optional_apply(aggregation_step_mean,
      aggregate.dht11_humidity, sample.dht11_humidity)};
    auto const dht11_humidity_count{state.dht11_humidity_count + 
      (sample.dht11_humidity.has_value() ? 1u : 0u)};
    auto const dht11_error{util::optional_apply(aggregation_step_min,
      aggregate.dht11_error, sample.dht11_error)};
    auto const bmp280_temperature{util::optional_apply(aggregation_step_mean,
      aggregate.bmp280_temperature, sample.bmp280_temperature)};
    auto const bmp280_temperature_count{state.bmp280_temperature_count + 
      (sample.bmp280_temperature.has_value() ? 1u : 0u)};
    auto const bmp280_pressure{util::optional_apply(aggregation_step_mean,
      aggregate.bmp280_pressure, sample.bmp280_pressure)};
    auto const bmp280_pressure_count{state.bmp280_pressure_count + 
      (sample.bmp280_pressure.has_value() ? 1u : 0u)};
    auto const bmp280_error{util::optional_apply(aggregation_step_min,
      aggregate.bmp280_error, sample.bmp280_error)};
    auto const brightness{util::optional_apply(aggregation_step_mean,
      aggregate.brightness, sample.brightness)};
    auto const brightness_count{state.brightness_count + 
      (sample.brightness.has_value() ? 1u : 0u)};
    auto const brightness_overrange{util::optional_apply(aggregation_step_max,
      aggregate.brightness_overrange, sample.brightness_overrange)};
    auto const brightness_error{util::optional_apply(aggregation_step_min,
      aggregate.brightness_error, sample.brightness_error)};
    auto const motion{util::optional_apply(aggregation_step_mean,
      aggregate.motion, sample.motion)};
    auto const motion_count{state.motion_count + 
      (sample.motion.has_value() ? 1u : 0u)};

    return std::pair<sensorhub, sensorhub_state>{{
        base_aggregate,
        ntc_temperature,
        ntc_overrange,
        ntc_error,
        dht11_temperature,
        dht11_humidity,
        dht11_error,
        bmp280_temperature,
        bmp280_pressure,
        bmp280_error,
        brightness,
        brightness_overrange,
        brightness_error,
        motion,
      }, {
        base_state,
        ntc_temperature_count,
        dht11_temperature_count,
        dht11_humidity_count,
        bmp280_temperature_count,
        bmp280_pressure_count,
        brightness_count,
        motion_count,
      }
    };
  }

  auto aggregation_step(
      dht22 const aggregate,
      dht22_state const state,
      dht22 const sample) {
    auto const [base_aggregate, base_state]{
      aggregation_step(static_cast<sensor>(aggregate),
                       static_cast<sensor_state>(state),
                       static_cast<sensor>(sample))};
    auto const temperature{util::optional_apply(aggregation_step_mean,
      aggregate.temperature, sample.temperature)};
    auto const temperature_count{state.temperature_count + 
      (sample.temperature.has_value() ? 1u : 0u)};
    auto const humidity{util::optional_apply(aggregation_step_mean,
      aggregate.humidity, sample.humidity)};
    auto const humidity_count{state.humidity_count + 
      (sample.humidity.has_value() ? 1u : 0u)};

    return std::pair<dht22, dht22_state>{{
        base_aggregate,
        temperature,
        humidity,
      }, {
        base_state,
        temperature_count,
        humidity_count,
      }
    };
  }

  auto aggregation_step(
      mhz19 const aggregate,
      mhz19_state const state,
      mhz19 const sample) {
    auto const [base_aggregate, base_state]{
      aggregation_step(static_cast<sensor>(aggregate),
                       static_cast<sensor_state>(state),
                       static_cast<sensor>(sample))};
    auto const co2_concentration{util::optional_apply(aggregation_step_mean,
      aggregate.co2_concentration, sample.co2_concentration)};
    auto const co2_concentration_count{state.co2_concentration_count + 
      (sample.co2_concentration.has_value() ? 1u : 0u)};
    auto const temperature{util::optional_apply(aggregation_step_mean,
      aggregate.temperature, sample.temperature)};
    auto const temperature_count{state.temperature_count + 
      (sample.temperature.has_value() ? 1u : 0u)};
    auto const status{util::optional_apply(aggregation_step_first,
      aggregate.status, sample.status)};
    auto const u0{util::optional_apply(aggregation_step_first,
      aggregate.u0, sample.u0)};
    auto const u1{util::optional_apply(aggregation_step_first,
      aggregate.u1, sample.u1)};

    return std::pair<mhz19, mhz19_state>{{
        base_aggregate,
        co2_concentration,
        temperature,
        status,
        u0,
        u1,
      }, {
        base_state,
        co2_concentration_count,
        temperature_count,
      }
    };
  }

  auto aggregation_step(
      lpd433_receiver const aggregate,
      lpd433_receiver_state const state,
      lpd433_receiver const sample) {
    auto const [base_aggregate, base_state]{
      aggregation_step(static_cast<sensor>(aggregate),
                       static_cast<sensor_state>(state),
                       static_cast<sensor>(sample))};
    auto const code{util::optional_apply(aggregation_step_first,
      aggregate.code, sample.code)};
    auto const n_bits{util::optional_apply(aggregation_step_first,
      aggregate.n_bits, sample.n_bits)};
    auto const intercode_gap{util::optional_apply(aggregation_step_first,
      aggregate.intercode_gap, sample.intercode_gap)};
    auto const pulse_length_short{util::optional_apply(aggregation_step_first,
      aggregate.pulse_length_short, sample.pulse_length_short)};
    auto const pulse_length_long{util::optional_apply(aggregation_step_first,
      aggregate.pulse_length_long, sample.pulse_length_long)};

    return std::pair<lpd433_receiver, lpd433_receiver_state>{{
        base_aggregate,
        code,
        n_bits,
        intercode_gap,
        pulse_length_short,
        pulse_length_long,
      }, {
        base_state,
      }
    };
  }

  auto aggregation_finish(
      sensor const aggregate,
      sensor_state const state) {
      auto const timestamp{util::optional_apply([=](auto const &x){
        return x / static_cast<cc::timestamp_duration_t>(state.timestamp_count); },
        aggregate.timestamp)};

    return sensor{
      timestamp,
    };
  }

  auto aggregation_finish(
      sensorhub const aggregate,
      sensorhub_state const state) {
    auto const base_aggregate{
      aggregation_finish(static_cast<sensor>(aggregate),
                         static_cast<sensor_state>(state))};
      auto const ntc_temperature{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.ntc_temperature_count); },
        aggregate.ntc_temperature)};
      auto const ntc_overrange{aggregate.ntc_overrange};
      auto const ntc_error{aggregate.ntc_error};
      auto const dht11_temperature{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.dht11_temperature_count); },
        aggregate.dht11_temperature)};
      auto const dht11_humidity{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.dht11_humidity_count); },
        aggregate.dht11_humidity)};
      auto const dht11_error{aggregate.dht11_error};
      auto const bmp280_temperature{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.bmp280_temperature_count); },
        aggregate.bmp280_temperature)};
      auto const bmp280_pressure{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.bmp280_pressure_count); },
        aggregate.bmp280_pressure)};
      auto const bmp280_error{aggregate.bmp280_error};
      auto const brightness{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.brightness_count); },
        aggregate.brightness)};
      auto const brightness_overrange{aggregate.brightness_overrange};
      auto const brightness_error{aggregate.brightness_error};
      auto const motion{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.motion_count); },
        aggregate.motion)};

    return sensorhub{
      base_aggregate,
      ntc_temperature,
      ntc_overrange,
      ntc_error,
      dht11_temperature,
      dht11_humidity,
      dht11_error,
      bmp280_temperature,
      bmp280_pressure,
      bmp280_error,
      brightness,
      brightness_overrange,
      brightness_error,
      motion,
    };
  }

  auto aggregation_finish(
      dht22 const aggregate,
      dht22_state const state) {
    auto const base_aggregate{
      aggregation_finish(static_cast<sensor>(aggregate),
                         static_cast<sensor_state>(state))};
      auto const temperature{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.temperature_count); },
        aggregate.temperature)};
      auto const humidity{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.humidity_count); },
        aggregate.humidity)};

    return dht22{
      base_aggregate,
      temperature,
      humidity,
    };
  }

  auto aggregation_finish(
      mhz19 const aggregate,
      mhz19_state const state) {
    auto const base_aggregate{
      aggregation_finish(static_cast<sensor>(aggregate),
                         static_cast<sensor_state>(state))};
      auto const co2_concentration{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.co2_concentration_count); },
        aggregate.co2_concentration)};
      auto const temperature{util::optional_apply([=](auto const &x){
        return x / static_cast<float>(state.temperature_count); },
        aggregate.temperature)};
      auto const status{aggregate.status};
      auto const u0{aggregate.u0};
      auto const u1{aggregate.u1};

    return mhz19{
      base_aggregate,
      co2_concentration,
      temperature,
      status,
      u0,
      u1,
    };
  }

  auto aggregation_finish(
      lpd433_receiver const aggregate,
      lpd433_receiver_state const state) {
    auto const base_aggregate{
      aggregation_finish(static_cast<sensor>(aggregate),
                         static_cast<sensor_state>(state))};
      auto const code{aggregate.code};
      auto const n_bits{aggregate.n_bits};
      auto const intercode_gap{aggregate.intercode_gap};
      auto const pulse_length_short{aggregate.pulse_length_short};
      auto const pulse_length_long{aggregate.pulse_length_long};

    return lpd433_receiver{
      base_aggregate,
      code,
      n_bits,
      intercode_gap,
      pulse_length_short,
      pulse_length_long,
    };
  }

  std::string name(sensor const &) {
    return std::string{"sensor"};
  }

  std::string name(sensorhub const &) {
    return std::string{"sensorhub"};
  }

  std::string name(dht22 const &) {
    return std::string{"dht22"};
  }

  std::string name(mhz19 const &) {
    return std::string{"mhz19"};
  }

  std::string name(lpd433_receiver const &) {
    return std::string{"lpd433_receiver"};
  }

  auto field_names(sensor const &) {
    return std::array<std::string, 1>{{
      std::string{"timestamp"},
    }};
  }

  auto field_names(sensorhub const &) {
    return std::array<std::string, 13>{{
      std::string{"ntc_temperature"},
      std::string{"ntc_overrange"},
      std::string{"ntc_error"},
      std::string{"dht11_temperature"},
      std::string{"dht11_humidity"},
      std::string{"dht11_error"},
      std::string{"bmp280_temperature"},
      std::string{"bmp280_pressure"},
      std::string{"bmp280_error"},
      std::string{"brightness"},
      std::string{"brightness_overrange"},
      std::string{"brightness_error"},
      std::string{"motion"},
    }};
  }

  auto field_names(dht22 const &) {
    return std::array<std::string, 2>{{
      std::string{"temperature"},
      std::string{"humidity"},
    }};
  }

  auto field_names(mhz19 const &) {
    return std::array<std::string, 5>{{
      std::string{"co2_concentration"},
      std::string{"temperature"},
      std::string{"status"},
      std::string{"u0"},
      std::string{"u1"},
    }};
  }

  auto field_names(lpd433_receiver const &) {
    return std::array<std::string, 5>{{
      std::string{"code"},
      std::string{"n_bits"},
      std::string{"intercode_gap"},
      std::string{"pulse_length_short"},
      std::string{"pulse_length_long"},
    }};
  }

  std::ostream &write_csv_fields(
      std::ostream &out, sensor const &data, bool const inner = false) {
    auto const original_precision{out.precision()};
    auto const original_width{out.width()};
    auto const original_flags{out.flags()};
    auto const original_fill{out.fill()};
    out << std::setfill(' ')
      << std::setprecision(cc::timestamp_decimals) << std::fixed
      << std::setw(1 + cc::timestamp_decimals + cc::timestamp_width)
      << io::csv::CSVWrapper<std::optional<cc::timestamp_duration_t>>{data.timestamp};
    if (inner) return out << std::setw(0) << cc::csv_delimiter_string; else {;
      out.precision(original_precision);
      out.width(original_width);
      out.flags(original_flags);
      out.fill(original_fill);
      return out << std::endl;
    };
  }

  std::ostream &write_csv_fields(
      std::ostream &out, sensorhub const &data, bool const inner = false) {
    auto const original_precision{out.precision()};
    auto const original_width{out.width()};
    auto const original_flags{out.flags()};
    auto const original_fill{out.fill()};
    write_csv_fields(out, static_cast<sensor>(data), true);
    out << std::setfill(' ')
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 3)
      << io::csv::CSVWrapper<std::optional<float>>{data.ntc_temperature}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << io::csv::CSVWrapper<std::optional<bool>>{data.ntc_overrange}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << io::csv::CSVWrapper<std::optional<bool>>{data.ntc_error}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 3)
      << io::csv::CSVWrapper<std::optional<float>>{data.dht11_temperature}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 3)
      << io::csv::CSVWrapper<std::optional<float>>{data.dht11_humidity}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << io::csv::CSVWrapper<std::optional<bool>>{data.dht11_error}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 3)
      << io::csv::CSVWrapper<std::optional<float>>{data.bmp280_temperature}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 8)
      << io::csv::CSVWrapper<std::optional<float>>{data.bmp280_pressure}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << io::csv::CSVWrapper<std::optional<bool>>{data.bmp280_error}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 5)
      << io::csv::CSVWrapper<std::optional<float>>{data.brightness}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << io::csv::CSVWrapper<std::optional<bool>>{data.brightness_overrange}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << io::csv::CSVWrapper<std::optional<bool>>{data.brightness_error}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(2) << std::fixed
      << std::setw(1 + 2 + 1)
      << io::csv::CSVWrapper<std::optional<float>>{data.motion};
    if (inner) return out << std::setw(0) << cc::csv_delimiter_string; else {;
      out.precision(original_precision);
      out.width(original_width);
      out.flags(original_flags);
      out.fill(original_fill);
      return out << std::endl;
    };
  }

  std::ostream &write_csv_fields(
      std::ostream &out, dht22 const &data, bool const inner = false) {
    auto const original_precision{out.precision()};
    auto const original_width{out.width()};
    auto const original_flags{out.flags()};
    auto const original_fill{out.fill()};
    write_csv_fields(out, static_cast<sensor>(data), true);
    out << std::setfill(' ')
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 3)
      << io::csv::CSVWrapper<std::optional<float>>{data.temperature}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 3)
      << io::csv::CSVWrapper<std::optional<float>>{data.humidity};
    if (inner) return out << std::setw(0) << cc::csv_delimiter_string; else {;
      out.precision(original_precision);
      out.width(original_width);
      out.flags(original_flags);
      out.fill(original_fill);
      return out << std::endl;
    };
  }

  std::ostream &write_csv_fields(
      std::ostream &out, mhz19 const &data, bool const inner = false) {
    auto const original_precision{out.precision()};
    auto const original_width{out.width()};
    auto const original_flags{out.flags()};
    auto const original_fill{out.fill()};
    write_csv_fields(out, static_cast<sensor>(data), true);
    out << std::setfill(' ')
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 4)
      << io::csv::CSVWrapper<std::optional<float>>{data.co2_concentration}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(1) << std::fixed
      << std::setw(1 + 1 + 3)
      << io::csv::CSVWrapper<std::optional<float>>{data.temperature}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(3)
      << io::csv::CSVWrapper<std::optional<int>>{data.status}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(3)
      << io::csv::CSVWrapper<std::optional<int>>{data.u0}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(3)
      << io::csv::CSVWrapper<std::optional<int>>{data.u1};
    if (inner) return out << std::setw(0) << cc::csv_delimiter_string; else {;
      out.precision(original_precision);
      out.width(original_width);
      out.flags(original_flags);
      out.fill(original_fill);
      return out << std::endl;
    };
  }

  std::ostream &write_csv_fields(
      std::ostream &out, lpd433_receiver const &data, bool const inner = false) {
    auto const original_precision{out.precision()};
    auto const original_width{out.width()};
    auto const original_flags{out.flags()};
    auto const original_fill{out.fill()};
    write_csv_fields(out, static_cast<sensor>(data), true);
    out << std::setfill(' ')
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(20)
      << io::csv::CSVWrapper<std::optional<uint64_t>>{data.code}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(2)
      << io::csv::CSVWrapper<std::optional<int>>{data.n_bits}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(5)
      << io::csv::CSVWrapper<std::optional<int>>{data.intercode_gap}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(5)
      << io::csv::CSVWrapper<std::optional<int>>{data.pulse_length_short}
      << std::setw(0) << cc::csv_delimiter_string
      << std::setprecision(cc::field_decimals_default) << std::defaultfloat
      << std::setw(5)
      << io::csv::CSVWrapper<std::optional<int>>{data.pulse_length_long};
    if (inner) return out << std::setw(0) << cc::csv_delimiter_string; else {;
      out.precision(original_precision);
      out.width(original_width);
      out.flags(original_flags);
      out.fill(original_fill);
      return out << std::endl;
    };
  }

  std::ostream &write_csv_field_names(std::ostream &out, sensor const &data,
      std::optional<std::string> const sensor_name_arg = {},
      bool const inner = false) {
    auto const original_precision{out.precision()};
    auto const original_width{out.width()};
    auto const original_flags{out.flags()};
    auto const original_fill{out.fill()};
    out << std::setw(0);
    std::string sensor_name{sensor_name_arg.value_or(name(data))};
    if (sensor_name != "") sensor_name += "_";

    auto const field_names_buffer{field_names(data)};
    for (auto const &field_name : field_names_buffer) {
      out << "\"" << sensor_name << field_name << "\"";
      if (inner or &field_name != &field_names_buffer.back())
        out << cc::csv_delimiter_string;
    }
    if (inner) return out; else {
      out.precision(original_precision);
      out.width(original_width);
      out.flags(original_flags);
      out.fill(original_fill);
      return out << std::endl;
    }
  }

  template<class T>
  std::ostream &write_csv_field_names(std::ostream &out, T const &data,
      std::optional<std::string> const sensor_name_arg = {},
      bool const inner = false) {
    auto const original_precision{out.precision()};
    auto const original_width{out.width()};
    auto const original_flags{out.flags()};
    auto const original_fill{out.fill()};
    out << std::setw(0);
    std::string sensor_name{sensor_name_arg.value_or(name(data))};
    if (sensor_name != "") sensor_name += "_";

    write_csv_field_names(out, static_cast<sensor>(data),
      std::optional<std::string>(sensor_name), true);

    auto const field_names_buffer{field_names(data)};
    for (auto const &field_name : field_names_buffer) {
      out << "\"" << sensor_name << field_name << "\"";
      if (inner or &field_name != &field_names_buffer.back())
        out << cc::csv_delimiter_string;
    }
    if (inner) return out; else {
      out.precision(original_precision);
      out.width(original_width);
      out.flags(original_flags);
      out.fill(original_fill);
      return out << std::endl;
    }
  }
} // namespace sensors
